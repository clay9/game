#+OPTIONS: ^:nil
#+OPTIONS: \n:t

* 待整理
** 模块意义
   | 模块名字 | 目录             | 意义             | 备注                            |
   |----------+------------------+------------------+---------------------------------|
   | net      | kernel除./kernel | 网络库           |                                 |
   |----------+------------------+------------------+---------------------------------|
   | kernel   | kernel/kernel    | 节点创建         | 1.该节点的作用(回调给frame处理) |
   |          |                  |                  | 2.与其他节点的关系(cfg控制)     |
   |----------+------------------+------------------+---------------------------------|
   | frame    | frame            | 节点具体业务处理 |                                 |
   |----------+------------------+------------------+---------------------------------|
   | etcd     | etcd服务         | 1.节点信息       |                                 |
   |          |                  | 2.节点配置文件   |                                 |
   |----------+------------------+------------------+---------------------------------|
   | redis    | redis服务        | 运行中的热点数据 |                                 |
   |----------+------------------+------------------+---------------------------------|

** server--kernel -- 耗时时间的设计
   实现: class funcost
   目标: 针对于Callback中消息号, 增加各处理端耗时打印
   具体信息:
   #+BEGIN_EXAMPLE c++ 具体打印信息
   struct time_dura{
         int64_t time_recv;       //从net读取的时间(耗时可能来源于 缓冲区一直有数据, 所以等待全部读完)
         int64_t time_in_cb;      //进入回调的时间(耗时来源于rbase的处理速度)
         int64_t time_new_over;   //内存开辟完成时间(耗时来源于内存开辟)
         int64_t time_handle;     //真正开始处理的时间(耗时来源于线程切换|等待)
         int64_t time_handle_over;//处理完成的时间(耗时来源于业务逻辑)
         int64_t time_send;       //真实的send时间(耗时来源于锁的争夺)
     };

   #+END_EXAMPLE

   分析:
   srcSvr查询
   1. query时间        -- 开始查询时间
   2. query Send时间   -- 发送时间 (耗时来源于锁的争夺)
      可以在SenMsg完成的地方调用

   center中转时间
   1. recv from net -- 从net读取的时间 (耗时可能来源于 缓冲区一直有数据, 所以等待全部读完)
      tcpconn.handleread() while之前调用
   2. 进入回调的时间  (耗时主要来源于rbase的处理速度)
      GameCtrl的onMsg回调中记录
   3. 内存开辟完成的时间(耗时来源于内存申请与copy)
   4. 真正开始处理的时间 (耗时来源于线程切换|等待)
      真实回调函数中记录
   5. 处理完成的时间 (耗时来源于业务逻辑)
      调用SendMsg之前记录
   6. 真实send的时间 (耗时来源于锁的争夺)
      SendMsg完成的地方调用

   tagSvr处理 -- 具体处理同上
   1. recv from net
   2. 进入回调的时间
   3. 真正开始处理的时间
   4. 处理完成的时间
   5. 真实send的时间

   srcSvr处理
   1. recv from net
   2. 进入回调的时间
   3. 真正开始处理的时间  -- 到此就可以知道从查询到回来的总耗时时间


* server--frame
  frame根据业务模块, 开放不同的server处理
** 模块总览
    1. [X] 登陆模块 - 重复登陆，断线重连. 登陆方式的支持， 账号密码， 游客， 微信等
    2. [X] 房间列表显示模块
       - [X] 房卡场 创建界面
       - [X] 金币场 列表展示
    3. [X] 房间创建流程
    4. [X] 子游戏模块
    5. [X] 房间结束后， 信息统计
       - [X] 大局战绩
       - [X] 小局战绩
       - [X] 录像回放
       - [X] 财富修改记录
    6. [X] 任务模块
    7. [X] 排行榜
    8. [X] 比赛场
    9. [ ] 活动模块
    10. [ ] 工会
** 服务器说明
   | 服务器名字 | 处理范围              | 有状态 | 状态量                        | 业务多线程 | 业务多线程原因   | 备注                           |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | center     | 路由                  | n      |                               | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | db         | 数据库代理            | n      |                               | y          | database操作耗时 |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | gate       | 网关                  | y      | map[gid, uid]                 | n          | 无业务逻辑       |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | logon      | 登录                  | n      |                               | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | lobby      | 大厅                  | n      |                               | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | game       | 查询, 创建, 加入 房间 | n      |                               | n          |                  | 加载了房卡场与金币场的配置文件 |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | match      | 比赛场服务器          | y      | match自身数据stage_index等    | n          |                  |                                |
   |            |                       |        | match_manager有map<int,match> |            |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | room       | 游戏房间的具体处理    | y      | 房间数据                      | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | rank       | 排行榜                | y      | rank_manager有map<int,rank>   | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | redis      | 维护redis数据         | n      |                               | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | task       | 任务                  | y      | task_manager有map<int,task>   | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | chat       | 聊天服务器            | n      |                               | n          |                  | ready to write                 |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | club       | 俱乐部服务器          | n      |                               | n          |                  | ready to write                 |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|
   | client     | 模拟client测试        | y      | ugmanager有map<gid,uid>       | n          |                  |                                |
   |------------+-----------------------+--------+-------------------------------+------------+------------------+--------------------------------|

   : 什么时候使用业务多线程
   : 当业务逻辑的处理时间耗时较久的时候, 使用业务多线程

   : 业务多线程优点 是加快了速度
   : 业务多线程缺点 编码复杂(增加了出错概率)

* server--约定俗称
*** 消息号命名规范
    为了client与server的统一, 消息号统一使用驼峰式命名, exp: SubQueryGoldRooms
    - 第一个字段 归属标志
      可能的赋值
      1) Sub  C端向S端查询
      2) Cmd  S端返回给C端
      3) L2G  logon->Game
      4) G2L  game->logon
     : 只有Lgon, game间的消息号使用 LG字样, 其他全部是Sub, Cmd
    - 第二个字段 意图  增删改查
    - 第三个字段 对象  被op对象 -- 可以没有
    - 第四个字段 消息号含义

    结构体的命名为 消息号前面增加Str
    函数的命名为 消息号前面增加On

*** 玩家的桌子号
    player.tableid
    含义:
    玩家在哪个桌子上

    用途:
    1. 登录的时候 判断断线重连
    2. 进入table时的校验, 防止加入2张桌子

    状态变化:
    1. roomSvr  table加入|坐下, 设置为桌子的tableid
    2. roomSvr  table离开,      如果是比赛场,设置为MATCH_TABLE, 否则INVALID_TABLE
    3. matchSvr 报名成功,       设置为MATCH_TABLE
    4. matchSvr 取消报名,       设置为INVALID_TABLE

*** 房间流程
    1. [X] 创建房间 -- 门票检测, 房间规则显示
       : GameServer处理
       : 房间规则使用rule_arry结构体传送给客户端显示
    2. [X] 加入房间 -- 门票检测
       : GameServer处理
       : 门票检测时 也会进行游戏资格检测
    3. [X] 房间规则在子游戏的显示
       : RoomServer frame处理
       : frame调用子游戏SubRuleDes()接口, 显示子游戏规则描述信息
    4. [X] 玩家信息在子游戏的显示
       : RoomServer frame处理
       : 玩家站起|坐下|准备|离开等动作, 会携带玩家信息, 发送给client
       : client根据动作, 判断是绘制还是删除玩家
       : 玩家财富变更后, LogonServer会通知client, 更改大厅的显示
       :                 如果在子游戏中, RoomServer frame会通知client, 更改子游戏的显示
       :                 即SubGame子游戏不再提供玩家分数相关信息给client
    5. [X] 游戏开始|一小局后 -- 门票扣除
       : RoomServer frame处理
       : 门票扣除信息 在RoomRuleCom中, 由GameServer生成
    6. [X] 每小局游戏结束 -- 游戏小局结算
       : RoomServer frame处理
       1) 小局结算写分
       2) 战绩记录
       3) 录像回放
    7. [X] 每局游戏结束后 -- 游戏资格检测
       : RoomServer frame处理
       : 数据在RoomRuleCom中, 由GameServer提供, 由CenterServer实际处理
* server--center
  center只负责路由转发, 不处理任何具体业务
** center 路由图
*** client <-> x
    #+BEGIN_SRC plantuml
title center route: client<->X
hide footbox
participant "Client" as ci << (C,#228b22) >>  order 1
participant "Gate"   as a  << (S,#ADD1B2) >>  order 2
participant "Center" as c  << (S,#ADD1B2) >>  order 3
participant "Logon"  as l  << (S,#ADD1B2) >>  order 4
participant "Lobby"  as h  << (S,#ADD1B2) >>  order 5
participant "Game"   as g  << (S,#ADD1B2) >>  order 6
participant "Room"   as r  << (S,#ADD1B2) >>  order 7


ci->a : request
a ->c : route with gid

alt  MainCMD::Logon
c ->l : route with (gid+gatesvr_id)
note left: find any logonsvr in svrmgr
note right: if login sucess, update uggr
l ->c : response (gid+gatesvr_id)
note left: find gatesvr by gatesvr_id
c ->a : route with gid
a ->ci: route

else MainCMD::Lobby
c ->h : route with uid
note left
find uid in uggr by gid,gatesvr_id
find any lobbysvr in svrmgr
end note
h ->c : response with uid
c ->a : route with gid
note right
find gid,gatesvr_id in uggr by uid
find gatesvr in svrmgr by gatesvr_id
end note
a ->ci: route

else MainCMD::Game
c ->g : route with uid
note left
find uid in uggr by gid,gatesvr_id
find any gamesvr in svrmgr
end note
g ->c : response with uid
c ->a : route with gid
note right
find gid,gatesvr_id in uggr by uid
find gatesvr in svrmgr by gatesvr_id
end note
a ->ci: route

else MainCMD::Room, MainCMD::SubRoom
c ->r : route with user
note left
find uid in uggr by gid,gatesvr_id
find roomsvr_fd in uggr by uid
find roomsvr in svrmgr by roomsvr_fd
end note
r ->c : response with user
c ->a : route with gid
note right
find gid,gatesvr_id in uggr by uid
find gatesvr in svrmgr by gatesvr_id
end note
a ->ci: route

else invalid-msg
c -> c
note left: do nothing
end
    #+END_SRC

    #+RESULTS:
    [[file:~/1.png]]

*** x <-> x
    #+BEGIN_SRC plantuml :file ~/2.png
title center route: X<->X
hide footbox
participant "X"      as x  << (S,#ADD1B2) >>  order 1
participant "Center" as c  << (S,#ADD1B2) >>  order 2
participant "Rank"   as k  << (S,#ADD1B2) >>  order 3
participant "Room"   as m  << (S,#ADD1B2) >>  order 4

alt CMDCB::RANK
  x->c: request with requestid
  note left: record map_logon<requestid, cb_f>
  c->k: route with requestid, xsvrid
  note left: find ranksvr in svrmgr
  k->c: response with requestid, xsvrid
  c->x: route with requestid
  note right: find x in svrmgr by svrid
  x->x: cb_f
  note left: delete map_logon[requestid]

else MainCB::ROOM
  x->c: request with requestid
  note left: record map_room<requestid, cb_f>
  c->m: route with requestid,xsvrid
  note left: find roomsvr in svrmgr
  m->c: response with requestid,fd
  c->x: route with requestid
  note right: find x in svrmgr by svrid
  x->x: cb_f
  note left: delete map_room[requestid]

end
    #+END_SRC

    #+RESULTS:
    [[file:~/2.png]]

** 玩家在哪个roomSvr上
   *查找方式*
   1. 根据redis.uggr中的r来确认roomserver id
   2. 先查找redis.player中的tableid,
      再查找redis.table_using中对应的serverid


   *两种方式差异*
   方式1多用于消息转发
   方式2多用于确认玩家是否在这个桌子(redis.player.tableid)上, 防止锁桌

* server--db
  db只负责转发database数据, 不处理任何具体业务
** 对外接口
   - call()
   - call_direct()

** 底层实现
   1. 对外接口底层使用callback代替msgid
      callback即自定义的RPC, 调用者可以直接在回调中处理结果数据
   2. 使用odbc驱动开发, 方便连接不同数据库
   3. 开启多个database实例, 供多线程业务层使用

** 注意事项
   1. 数据的读取顺序 必须与 db存储过程返回的顺序一致

* server--gate
  gate不负责具体业务逻辑, 转发所有数据到center

  gate作用:
  1. 过滤无效数据(socket协议数据不符的), 减少攻击对后面svr的影响
  2. client的接口, 对client隐藏后面的svr

* server--logon
  登陆服务, 更新uggr
** 重复登陆
   *判断依据*
   uggr中的gatesvrid, gid与center传递来的gatesvrid, gid进行比较,
   不一致为重复登录, 一致可能是client多次发起登录请求

   *重复处理*
   1. 通知gateSvr踢出之前的玩家c
      gateSvr校验gid,uid, 如果一致则通知client被提出, 并断开其连接
   2. 更新uggr
** 断线重连
   *判断依据*
   1. redis.player_uid中的tableid != INVALID_TALBE
   2. redis.uggr中的r != 0

   *断线处理*
   1. 如果断线, 向对应的roomSvr查询, 确认玩家是否真的在roomSvr的桌子中.
      根据结果更新uggr

* server--lobby
  大厅一些业务的处理, 当前为战绩和录像查询
* server--game
  房间配置查询 && 创建房间
  加载所有子游戏的fk和gold配置
** 对外接口
   - GetRoomRule 根据传递的规则选择, 获取房间规则
** 配置文件
   配置文件放在
   subgames/kindid/kindid.fk
   subgames/kindid/kindid.gold
** 房间规则配置
*** 房间规则分析
    *房间规则由来*
    对于每一个具体的游戏来讲, 游戏本身是规则下的流程
    这里的规则分为两大类
    一类是游戏自身的规则, 比如斗地主需要一副牌, 有三带一等各种牌型.
    这种规则本身变化不大, 影响的是游戏自身的流程.
    还有一类规则是影响游戏逻辑之外的, 比如3小局, 4小局. 比如这是房卡场的, 金币场的等等

    于是我们把所有游戏共用的规则(主要是第二类规则), 提取出来放到tagRoomRuleCom
    而对于每个子游戏不同的游戏规则, 我们只需要提供map<key, choose_index>给子游戏即可

    房间规则不区分游戏玩法.
    房卡场, 金币场, 比赛场, 俱乐部玩法的房间规则使用同一个结构体tagRoomRule
    通用房间规则 是指抽象出来供frame使用的, 使用统一结构体tagRoomRuleCom
    子游戏规则   是每个子游戏自身的规则, 在frame层以map<key, choose_index>的形式传递给子游戏, 由子游戏自己解析


    *房间规则继续分析*
    无论对于tagRoomRuleCom 还是map<key, choose_index> 都可以认为是key, value的键值对
    所以我们配置文件, 可以采取最基本的key, value形式.
    但是考虑到房卡场, 金币场等具体玩法, 我们期待的金币场也可以配置自身的游戏规则.
    比如初级场可以配置为3小局, 底分2; 中级场可以配置为2小局, 底分5;
    因此可以再进一步抽象为
    1. 先提供一个可供选择的规则配置
    2. 需要什么样的规则, 只要提供对应的choose, 就可以生成具体的tagRoomRule

*** 房间规则配置
    *目标*
    1. 金币场, 比赛场, 俱乐部模式 更好的配置游戏规则
    2. 对于房卡场, 服务器控制client的房间规则显示
       client开发的时候 不需要做任何处理


    *client使用流程*
    1. client申请创建房间
    2. server判断是否符合创建条件,  发送房间规则配置 rule_arry(在STR_Common.proto中)
       其中css控制client显示的样式
       rule表示一条规则
       #+BEGIN_EXAMPLE sh 配置举例
       css
       1
       2
       特殊规则 3, 4, 5

       rule_1  人数
       rule_2  局数
       rule_3  炸弹
       rule_4  鬼子
       rule_5  天王九
       #+END_EXAMPLE
       #+BEGIN_EXAMPLE sh client显示的样式
       人    数   "2" "3" "4"
       局    数   "2" "3" "4"
       特殊规则   炸弹o  鬼子o 天王九o
       #+END_EXAMPLE
    3. client返回 选择结果 repeated int32
       比如: 上面选择了 2人 4局, 则返回
       0
       2
       每个返回字段为byte, 返回的value index
    4. server收到后, 构造房间规则tagRoomRule


    *其他游戏模式使用流程*
    对于金币场,比赛场等使用更加简单, 直接提供choose_values即可

* server--match
** 设计理念
   matchSvr负责维护 {uid, score} 排行,
   具体的数据是roomSvr通知的matchSvr
   : match没有必要把同排行的人放到一个roomSvr, 因此不需要指定roomSvr
** 组织架构
   #+BEGIN_EXAMPLE
     kind1  --  match-type 1  -- match 1 -- {对应一系列桌子}
                              -- ....
                              -- match N
            --  ....
            --  match-type N
     ....
     kind N
   #+END_EXAMPLE

** 流程
   1. 玩家申请加入某个比赛场match_type, 如果没有空的match, 则创建一个match, 放入玩家
      设置其tableid为MATCH_TABLE, 防止进入其他桌子
      如果玩家取消比赛, tableid重置为INVALID_TABLE
      玩家掉线的时候, 如果还在比赛排队状态(tableid为MATCH_TABLE), 则按取消比赛处理
   2. 当match满足触发条件之后, 开始比赛
      matchSvr把玩家分组, 并通知roomSvr创建桌子
   3. roomSvr进行游戏, 当table大局结束的时候, 把数据(score)返回给matchSvr
   4. matchSvr进行排序, 重新分组, 继续通知roomSvr开始游戏
   5. 循环直至比赛结束为止
** 依赖关系
   依赖GameSvr, 需要GameSvr提供的GetRoomRule()接口
** 缺陷
   有状态的, 需要后期改为无状态服务器
** 配置文件
   配置文件放在subgames/kinid/kindid.match中

* server--room
** 对外接口
   - GetTable       获取table状态信息
   - GetTableUser   获取玩家是否在桌子上
   - EnterTable(uid, tableid)               进入桌子
   - EnterTable(uid, tagRoomrule)           进入桌子
   - EnterTable(vector<uid>, tagRoomrule)   进入桌子
** table设计思路
   roomSvr中的table是最基本的table, 不考虑金币场, 比赛场, 俱乐部
   只处理游戏逻辑

   也就是说, 这里Table不区分房卡场, 金币场等
   对自身影响范围:
   1. [X] 门票的问题
      门票无需特意处理, 因为在创建房间之前, 门票就已经算清楚了
   2. [X] 算分的问题
      只是把结果放出来, 至于具体如何处理, table可以不需要关心

** 战绩 && 录像回放
*** 查询
    数据存放在database中
    player_score 战绩-玩家信息
    table_record 战绩-桌子信息
    table_video  录像回放

    模拟运行:
    1. 查看大局战绩
       : player_score与table_record联查, onlyid为连接标志
       : 根据player_score.userid 与 table_record.clubid 找出top 100的onlyid
       : 根据onlyid和curcount=0 在player_score中查找所有符合条件的数据
       : 最后联查player, 联查标记为userid
    2. 查看小局战绩
       : 根据onlyid 在player_score查找即可
       : 最后联查player, 联查标志位userid
    3. 查看录像回放
       : 根据onlyid, curcount 在table_video中查找即可

*** 录像回放 写入
    1. RoomServer frmae中处理, 子游戏不需要考虑
    2. frame的SendTable()函数中, 调用录像类记录
    3. 在小局结束的时候, 调用录像类获取数据
       : 这里的数据是proto序列化为string后, 又转为了raw-string, 方便写入数据库
    4. 数据库读取出raw-string, 转为string, 再转为录像数据table_video结构体
    5. 子游戏只需要解析table_video即可

** 小局结束 数据处理
   1. [X] 玩家 门票
   2. [X] 玩家 财富变更
   3. [X] 玩家 具体输赢情况
   4. [X] 玩家 任务系统
   5. [X] 桌子 战绩
   6. [X] 桌子 回放


   财富变更表 -- 比较独立的表格 player_log_treasure
   | 玩家id | 财富类型 | 财富数量 | 备注说明 | 插入时间 |
   |--------+----------+----------+----------+----------|

   玩家输赢情况表 player_score
   | 玩家id | 当前桌子局数 | 椅子位置 | 分数 | 大赢家标志 | 唯一标志 | 插入时间 |
   |--------+--------------+----------+------+------------+----------+----------|

   战绩表 table_record
   | 桌子ID | 桌子类型(房卡, 金币) | 总局数 | 桌子玩家数 | KindID | clubid | 子游戏信息 | 唯一标志 | 插入时间 |
   |--------+----------------------+--------+------------+--------+--------+------------+----------+----------|

   战绩回放表 table_video
   | 当前桌子局数 | 回放数据 | 唯一标志 | 插入时间 |
   |--------------+----------+----------+----------|

   备注说明:
   1. 玩家财富变更均通过 玩家财富变更记录表 -- 所有财富类型
   2. 战绩表 只 记录桌子信息, 而不记录 玩家输赢信息

** 玩家动作 坐下|起立|离开|解散|换桌(金币场)
   玩家加入
   玩家坐下
   玩家起立
   玩家离开
   金币换桌
*** 旁观的处理
    : 是否旁观是由服务器根据桌子状态来判断的
    玩家加入房间的时候
    如果房间已经开始&&允许旁观, 则可以设置为旁观状态
    如果房间没有开始, 则是坐下状态

** 玩家状态
   状态1 UserStatusL
   状态2 UserStatusH
   : 两者非互斥关系, UsetStatusL内部为互斥关系, UserStatusH内部为互斥关系
   : 掉线之后未必为托管状态, 掉线8s之后, 将由掉线状态变为托管状态; 当掉线回来后, 托管状态自动取消

   #+BEGIN_EXAMPLE c++
//用户状态 low
enum UserStatusL
{
   FREE_L=0;      //没有状态
   SIT = 1;       //坐下
   STANDUP =2;    //站立(旁观)
   READY= 3;      //准备状态
   PLAYING=4;     //游戏中
};
//用户状态 high 与low不互斥
enum UserStatusH
{
   FREE_H =0;     //正常状态
   TUOGUAN =1;    //托管
   OFFLINE=2;     //掉线 -- 掉线8s之后设置为托管状态
};
   #+END_EXAMPLE

** 椅子视图
   唯一视图 真实的椅子位置
   frame: m_player_list与真实椅子视图 是通过CPlayer来转换的
   subgame: subgame实现了真实的椅子视图
   client: client存在C视图 与 真实椅子视图(S视图)的转换

** tableid生成方式
   table 由redis启动的时候预先生成100000-999999
   table_using使用zset记录tableid, 创建time. 后面删除的时候, 根据time来有选择的删除,
   比如删除5分钟之前的桌子, 提高效率.

* server--rank
** 配置文件
   *配置文件放在database rank表*
   | id   | rank_name | rank_desc | type           | sortid | award | valid    |
   | 自增 | 名字      | 描述      | 类型(唯一标志) | 优先级 | 奖励  | 是否开启 |

   读取rank
   load_rank
** 定时功能的设计
   自定义定时操作
   缺点非常明显, 如果Svr挂了, 那么可能会导致数据错乱
   所以需要额外考虑svr挂掉的情况
* server--redis
  redis 控制服务
  1. 初始化redis
  2. redis中机器人对回收等
* server--task
** 对外接口
   - PushTask(task_type, uid, score)
** 流程图
    #+BEGIN_EXAMPLE
     +--------+
     | start  |
     +--------+
         |
         |
         v
     +--------+  否
     | 触发   |------------+
     +--------+            |
       是|                 |
         |                 |
         v                 |
     +--------+  否        |
     |  完成  | -----+     |
     +--------+      |     |
         |           |     |
      是 |           |     |
         v           |     |
     +--------+      |     |
     | updata | <----+     |
     +--------+            |
         |                 |
     +---v----+            |
     | end    | <----------+
     +--------+
    #+END_EXAMPLE
    1. 触发条件判断
       - 时间start - end范围
       - 特定kind, 特定room_level下的任务.
         比如完成斗地主高级场一次
       - 用户身份的限定
         比如vip才可完成的任务
    2. 完成条件的判断
       1) 需要先根据周期重置来重置任务完成状况
       2) 任务完成状况与task配置中的任务step_all比较, 判断是否完成
    3. update
       更新任务完成状况
** 配置文件 && 中间状态
   *配置文件放到database task表*
   | 名称 | 描述 | 类型 | 优先级   | 开始时间   | 结束时间 | 重置周期     | 其他触发限制 | 总步数   | 奖励配置 |
   | name | desc | type | priority | start_time | end_time | reset_period | on_xml       | step_all | award    |

   type解释,
   斗地主初级场1次, 斗地主初级场2次, 斗地主初级场3次
   那么他们的type可以一致, 并设置priority分别为1,2,3
   这样就可以认为这三个任务是阶段性任务. 先完成斗地主初级场1次后, 才会显示斗地主初级场2次;
   完成斗地主初级场2次后,才会显示斗地主初级场3次. 形成一个阶段

   所以type相同, 认为是同一种类型任务(触发流程, 完成流程都一致), 而priority可以区分其阶段.


   *中间状态放到redis task_status_$uid_$taskid表*
   | uid | 任务id | 当前步数     | 任务完成时间 | 任务状态 |
   | uid | taskid | step_current | time         | status   |

   time应该是任务完成的时间. 昨天完成的时间, 到了今天也会重置
   status 0 未完成, 1完成未领奖, 2完成已领奖
** 任务类的设计
    1. Task
       - tagTask 任务配置的数据结构
       - 触发逻辑判断 task::bOn(...) 入参可能较多
       - 完成逻辑判断 task::bComplete(tagTaskStatus)
    2. TaskManager
       - map<taskid, Task>
       - 更新逻辑 TaskManager::updata()
       - 获取不同mtype(或sub_type)的任务
       - 增加, 删除任务

* TODO server--chat
* TODO server--club
* server--client
  模拟client, 对整个svr进行数据测试
* server--子游戏
  1. 子游戏处理范围
     游戏开始 -- 大局结束
  2. 子游戏不涉及到玩家的财富
     只会通知frame增减财富
     client子游戏玩家财富信息的显示, 实际由frame控制, 而非子游戏

** 组织架构
   FrameWork -->  TableFrameSink --> GameData

   备注: 1. tableFrameSink只是处理流程, 所有的数据都在GameData中
   2. CGameCardConfig 是GameData的辅助类.

** 牌类数据描述
   玩家 使用16位表示
   高四位 表示 玩家类型的ID  -- 比如 地主, 农民
   再四位 表示 玩家数量
   低8位  表示 玩家手牌数量


   牌使用16位表示
   高四位  表示 卡牌点数
   中四位  表示 卡牌颜色
   低8位   表示 卡牌类型组 -- groupID, 配置文件挂钩

   1方块; 2梅花; 3红桃; 4黑桃; 5表示特殊牌,  比如大王小王
   大王小王 花色为5， 值分别为 15 14

** protobuf结构
   1. 消息号
   2. 游戏状态 (抢庄, 下注, 发牌 ....) -- 断线重连相关
   3. 自定义enum, 比如牌型, 定时器等
   4. 消息号对应的结构体
   5. 断线重连对应的结构体 -- 与游戏状态一一对应
   6. 战绩中 显示的子游戏信息


* redis
** 已使用字段
   | 含义               | key                      | val                 | val_type_in_redis | 备注       |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 玩家信息           | player_$uid              | tagUserInfo         | string            | 含robot    |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 可用机器人         | robot                    | set<uid>            | unordered_set     |            |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 已用机器人         | robot_using              | set<uid>            | unordered_set     |            |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 排行榜             | rank_$rankid             | zset<uid,score>     | ordered_set       |            |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 排行榜过期时间     | rank_$rankid_expire      | int64_t             | string            | 毫秒       |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 玩家任务状态       | task_status_$uid_$taskid | tagTaskstatus       | string            |            |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | uggr索引uid        | uggr_$uid                | tagUggr             | string            | 不含机器人 |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | uggr索引gateid+gid | uggr_gg_$gatesvrid_$gid  | uid                 | string            | 不含机器人 |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 可用桌子号         | table                    | set<tableid>        | unordered_set     |            |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 已用桌子号         | table_using              | zset<tableid, time> | unordered_set     |            |
   |--------------------+--------------------------+---------------------+-------------------+------------|
   | 已用桌子号         | table_using_$tableid     | $severid_$kindid    | string            |            |
   |--------------------+--------------------------+---------------------+-------------------+------------|
** 已使用lock字段
   | 含义         | key              | 备注                 |
   |--------------+------------------+----------------------|
   | 玩家信息锁   | lock_player_$uid |                      |
   |--------------+------------------+----------------------|
* etcd
  !!! 已舍弃
** 创建容器
  docker run -d --name qy-etcd \
    --network app-tier \
    --publish 2379:2379 \
    --publish 2380:2380 \
    --env ALLOW_NONE_AUTHENTICATION=yes \
    --env ETCD_ADVERTISE_CLIENT_URLS=http://etcd-server:2379 \
    k8s.gcr.io/etcd:3.5.0-0


  docker run -d --name qy-etcd \
    --network app-tier \
    --publish 2379:2379 \
    --publish 2380:2380 \
    --env ALLOW_NONE_AUTHENTICATION=yes \
    --env ETCD_ADVERTISE_CLIENT_URLS=http://127.0.0.1:2379 \
    bitnami/etcd:latest
** http接口
   //注意range的范围为 [key, range_end)
   //put && get && get all && watch
   curl -L http://127.0.0.1:2379/v3/kv/put -X POST -d '{"key": "lili", "value": "wang"}'
   curl -L http://localhost:2379/v3/kv/range -X POST -d '{"key": "lili"}'
   curl -L http://localhost:2379/v3/kv/range -X POST -d '{"key": "svr1", "range_end": "svr2"}'
   curl -N http://localhost:2379/v3/watch -X POST -d '{"create_request": {"key":"svr/lili"} }' &

   //172.23.0.1
   curl -L http://172.23.0.1:2379/v3/kv/put -X POST -d '{"key": "L3N2ci8=", "value": "0002"}'
   curl -L http://172.23.0.1:2379/v3/kv/range -X POST -d '{"key": "c3Zy"}'
   curl -L http://localhost:2379/v3/kv/range -X POST -d '{"key": "S001", "range_end": "S003"}'
   curl -N http://localhost:2379/v3/watch -X POST -d '{"create_request": {"key":"L3N2ci8="} }'
** 使用总结
   *阶段一*
   尝试使用http (kernel内置支持)
   但因为base64问题, 舍弃

   *阶段二*
   尝试接入etcd官方指定的cpp网络库
   但因为protobuf版本, 运行不了. 通知因为编译依赖boost, 导致容器变得非常大. 舍弃

   *阶段三*
   继续使用http, 并解决base64问题(etcd中依然无法查看具体内容, 被转义了)
   因为watch舍弃. 解决不了watch的前缀问题

   *阶段四*
   代码中调用shell, shell调用etcdctl. 通过etcdctl间接操作


   *总结`*
   不要拘泥于代码, 代码,进程,容器等等, 均可使用


* 后期
  1. write && get redis中玩家数据时候 需要上锁
     - CPlayer中写入的时候都需要上锁
  2. 内存泄漏
     valgrind
  3. 无状态服务
     无状态的意义 在于方便开启一个集群
     思考一下 rank, task, match是否需要修改为无状态的
  4. callback 这里的错误处理
     struct A 序列化后的结果, 用struct B parse, 居然是正常的...
     这会导致后续 服务器非常容易崩溃, 必须解决该问题
  5. TCPCommand结构体修改
     - qybase
     - qykernel
     - frame -- 与frame是否有影响


* todonow
  1. [ ] qybase 优化
     - [ ] 优化对外接口
       : 隐藏net_tools, 简化net
       : 这块改动太大, 后期修改
  2. [ ] kernel 优化
     - [ ] 优化kernel与base, log, db等的接口设计
       : log比较麻烦, 但是很有必要, 统一log接口设计, 为后期更换glog等做准备
